Slip5.txt

 Q1 Bankers Algorithm

#include<stdio.h>
int N; // no of process
int M; // no of res type in system
int Available[10];
int tempAvailable[10];
int Max[10][10];
int Alloc[10][10];
int Need[10][10];
int safeseq[10];
void AcceptInput()
{
	int i;
	int j;
	printf("\nEnter the number of process:");
	scanf("%d",&N);
	printf("\nEnter the number of res type:");
	scanf("%d",&M);
	printf("\nEnter Available:");

	for(i = 0; i < M; i++)
	{
	printf("\nEnter number of instance for res type %c:",65+i);
		scanf("%d",&Available[i]);
		tempAvailable[i] = Available[i];
	}
	printf("\nEnter Max:\n");
	for(i = 0; i < N; i++)
		for(j = 0; j < M; j++)
		{
		printf("\nEnter Max for Process P%d, Res[%c]",i,65+j);
			scanf("\n%d",&Max[i][j]);
		}

	printf("\nEnter Allocation:\n");
	for(i = 0; i < N; i++)
		for(j = 0; j < M; j++)
		{
	printf("\nEnter Alloc for Process P%d, Res[%c]",i,65+j);
			scanf("\n%d",&Alloc[i][j]);
		}

	for(i = 0 ; i < N; i++)
		safeseq[i] =-1;
}
void DisplayMatrix(int a[10][10], int N, int M)
{
	int i,j;
	for(i = 0; i < N; i++)
	{
		for(j = 0; j < M; j++)
			printf("%5d",a[i][j]);

		printf("\n");
	}

}
void CalNeed()
{
	int i,j;
	for(i = 0; i < N; i++)
		for(j = 0; j < M; j++)
			Need[i][j] = Max[i][j] - Alloc[i][j];

}
int IsFeasible(int Pno)
{
	int i;
	for(i = 0; i < M; i++)
		if(Need[Pno][i] > Available[i])
			return 0;
	
	return 1;
}
void Banker()
{
	int k =0;
	int i,j;
	int flags[5] = {0,0,0,0,0};
	int finish = 0;
	while(finish != 1)
	{
		for(i = 0; i < N; i++)
		{
			if(IsFeasible(i) && flags[i] != 1)
			{
		//1. REMOVE FROM AVAILABLE i.e Avail = Avail - Need
			for(j = 0; j < M ; j++)
			Available[j] = Available[j] - Need[i][j];
			
			//2. Add need to allocation
			for(j = 0; j < M ; j++)
			Alloc[i][j] = Alloc[i][j] + Need[i][j];

		//3. process releases res hence Avail = Avail + Alloc
			for(j = 0; j < M ; j++)
				Available[j] = Available[j] + Alloc[i][j];

			//4. Add process in Safe Seq
			safeseq[k++] = i;
			flags[i] = 1;
			}
		}

		for(i = 0; i < N; i++)
			if(flags[i] == 1)
				continue;
			else 
				break;
	
		if(i == N)
			finish = 1;
	}
}

void PrintSafeSeq()
{
	int i;
	printf("\nSafe Seq\n");
	printf("\n<");
	for(i = 0; i < N; i++)
		printf("p%d,",safeseq[i]);

	printf("\b>\n");
}
void NewRequest()
{
	int i;
	int NewReq[10];
	for(i = 0; i < M; i++)
	{	printf("\nEnter %c:",65+i);
		scanf("%d",&NewReq[i]);
	}
	for(i = 0; i < M; i++)
		if(NewReq[i] > tempAvailable[i])
			break;
		else
			continue;
	if(i != M)
	printf("\nNot Feasible, Hence resource cannot be granted");
	else
		printf("\nFeasible, and request can be granted");

}
int main()
{
	AcceptInput();
	CalNeed();
	printf("\nMAX:\n");
	DisplayMatrix(Max,N,M);
	printf("\nALLOCATION:\n");
	DisplayMatrix(Alloc,N,M);
	printf("\nNEED:\n");
	DisplayMatrix(Need,N,M);
	Banker();
	PrintSafeSeq();
	NewRequest();

	return 0;
}



 Q2 Find max number from randomly generated 1000 numbers

   #include<stdio.h>
#include<mpi.h>
#include<stdlib.h>

#define N 1000
int main(int argc, char**argv)
{
	int rank,size;
	MPI_Init(&argc,&argv);
	MPI_Comm_rank(MPI_COMM_WORLD, &rank);
	MPI_Comm_size(MPI_COMM_WORLD, &size);

	int i;
	int local_min=100;
	int local_max=0;
	int global_min, global_max;
	int *arr=(int*)malloc(N * sizeof(int));
	
	srand(rank);
	
	for(i=0;i<N;i++)
	{
		arr[i]=rand()%100;
		if(arr[i]<local_min)
		{
			local_min=arr[i];
		}
		if(arr[i]>local_max)
		{
			local_max=arr[i];
		}
		
        }
        
        MPI_Reduce(&local_min,&global_min,1,MPI_INT,MPI_SUM,0,MPI_COMM_WORLD);
	MPI_Reduce(&local_max,&global_max,1,MPI_DOUBLE,MPI_SUM,0,MPI_COMM_WORLD);
	
	if(rank==0)
        {
        printf("Global min=%d\n",global_min);
	printf("Global max=%d\n",global_max);
        }
        MPI_Finalize();
}                

